/* This is the package for this particular plug-in. Third-party
** applications will want a different package name, but it is
** *ESSENTIAL* that the package name contain the string '.metrics.'
** because this is how Alitheia Core discovers the metric plug-ins. 
*/
package gr.tracer.vulnerabilitydetectors.framacvd;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.osgi.framework.BundleContext;


/* These are imports of standard Alitheia core services and types.
** You are going to need these anyway; some others that you might
** need are the FDS and other Metric interfaces, as well as more
** DAO types from the database service.
*/
import eu.sqooss.core.AlitheiaCore;
import eu.sqooss.service.abstractmetric.AlreadyProcessingException;
import eu.sqooss.service.abstractmetric.MetricDecl;
import eu.sqooss.service.abstractmetric.MetricDeclarations;
import eu.sqooss.service.abstractmetric.Result;
import eu.sqooss.service.db.DBService;
import eu.sqooss.service.db.Metric;
import eu.sqooss.service.db.ProjectFile;
import eu.sqooss.service.fds.CheckoutException;
import eu.sqooss.service.util.FileUtils;
import gr.tracer.common.ConfigurationHandlingMode;
import gr.tracer.common.DetectedVulnerabilities;
import gr.tracer.common.DetectedVulnerability;
import gr.tracer.common.ExternalToolInvocationMode;
import gr.tracer.common.VulnerabilityDetectorBase;
import gr.tracer.common.entities.db.ProjectFileVulnerability;
import gr.tracer.common.entities.db.VulnerabilityType;
import gr.tracer.platform.TracerPlatform;
import gr.tracer.platform.components.SecurityProfileComponent;
import gr.tracer.platform.components.VulnerabilityDetectionComponent;

/**
 * The VDSkeleton class actually implements the metrics and vulnerability
 * detection in this plug-in. It must extend VulnerabilityDetectorBase, so
 * that it can be called by the various metrics drivers.
 *  
 */ 
@MetricDeclarations(metrics= {
		@MetricDecl(mnemonic="FC.DBLFREE", activators={ProjectFile.class}, descr="FramaC: Double Free Vulnerability"),
		@MetricDecl(mnemonic="FC.FMTSTR", activators={ProjectFile.class}, descr="FramaC: Format String Vulnerability"),
		@MetricDecl(mnemonic="FC.SQLINJ", activators={ProjectFile.class}, descr="FramaC: SQL Injection Vulnerability"),
		@MetricDecl(mnemonic="FC.UKTERR", activators={ProjectFile.class}, descr="FramaC: User Kernel Trust Error Vulnerability"),
		@MetricDecl(mnemonic="FC.XSS", activators={ProjectFile.class}, descr="FramaC: XSS Vulnerability")
})
@DetectedVulnerabilities(vulnerabilities = {
	@DetectedVulnerability(name="DoubleFree", description="Dynamic memory management problem",	activators={ProjectFile.class}),
	@DetectedVulnerability(name="FormatString", description="Format string problem",	activators={ProjectFile.class}),
	@DetectedVulnerability(name="SQLInjection", description="SQL Injection Vulnerability",	activators={ProjectFile.class}),
	@DetectedVulnerability(name="UserKernelTrustError", description="Dereferencing kernel info problem",	activators={ProjectFile.class}),
	@DetectedVulnerability(name="XSS", description="Cross site scripting attack",	activators={ProjectFile.class})
})
public class FramaCVD extends VulnerabilityDetectorBase {
    
	/** Reference to the DB service */
	private DBService dbs;
	
	static String FRAMAC_PATH = "";
	static String FRAMAC_CFG_PATH = "";
	// Alternatively we could use the form config -> list<Params<name, value>>
	static Map<String, String> configurationMetrics; // config -> metric mnemonic
	
	//patterns for parsing FRAMA-C output
	static String splitEntryPatternRegex = ".*\\nEnvironment for function\\s*([^:]+):";
	static String symnamePatternRegex = "\\s*Symname:\\s*([\\S]+)\\s*=\\s*(.*)";
	static Pattern splitEntryPattern = Pattern.compile(splitEntryPatternRegex);
	static Pattern symnamePattern = Pattern.compile(symnamePatternRegex);
	
	static {
		configurationMetrics = new HashMap<String, String>();
		configurationMetrics.put("DoubleFree", "FC.DBLFREE");
		configurationMetrics.put("FormatString", "FC.FMTSTR");
		configurationMetrics.put("SQLInjection", "FC.SQLINJ");
		configurationMetrics.put("UserKernelTrustError", "FC.UKTERR");
		configurationMetrics.put("XSS", "FC.XSS");
    }
	
	/**
	 * Store the configuration files in a folder relative to the working directory so that
	 * they can be used by the external tool
	 * @author circular 
	 */
	private static void exportConfigurations(){
		
		for(String conf: configurationMetrics.keySet()) {
			try {
				File dirPath = new File(String.format("%s/configurations/%s",FRAMAC_CFG_PATH,conf));
				dirPath.mkdirs();
				dirPath = new File(String.format("%s/results/%s",FRAMAC_CFG_PATH,conf));
				dirPath.mkdirs();
				String defCfgUrl = String.format("configurations/%s/default.cfg", conf);
				String defConstrCfgUrl = String.format("configurations/%s/default_constr.cfg", conf);
				
				exportConfigurationResource(defCfgUrl);
				exportConfigurationResource(defConstrCfgUrl); 
			} catch(Exception ignore) {
				continue;
			}
		}
	}

	private static void exportConfigurationResource(String resourceUrl)
			throws FileNotFoundException, IOException {
		FileOutputStream out = new FileOutputStream(String.format("%s/%s", FRAMAC_CFG_PATH, resourceUrl));
		FileInputStream in = new FileInputStream(String.format("/home/rafailidis/Alitheia-Core/tracer/vulnerabilitydetectors/framacvd/src/main/resources/%s", resourceUrl));
//		InputStream in = FramaCVDActivator.bundle.getResource(resourceUrl).openStream();
		
		int read;
		byte[] buff = new byte[1024];
		while ((read = in.read(buff)) != -1) {
		    out.write(buff, 0, read);
		}
		
		in.close();
		out.close();
	}
	
	@Override
	public boolean install() {
		try {
			boolean result = super.install();
			if(result) {
				setExternalToolPath("frama-c.byte");
				setExternalToolInvocationMode(ExternalToolInvocationMode.PER_PROJECT_FILE);
				setConfigurationHandlingMode(ConfigurationHandlingMode.ALL_CONFIGURATIONS);
			}
	        return result;
		} catch(Exception e) {
			log.warn(e.toString());
		}
		return false;
	};
	
    public FramaCVD(BundleContext bc) {
    	super(bc);
    	configurations.put("DoubleFree", "-config-file configurations/DoubleFree/default.cfg -constr-config-file configurations/DoubleFree/default_constr.cfg -taint-analysis -print-final");
        configurations.put("FormatString", "-config-file configurations/FormatString/default.cfg -constr-config-file configurations/FormatString/default_constr.cfg -taint-analysis -print-final");
        configurations.put("SQLInjection", "-config-file configurations/SQLInjection/default.cfg -constr-config-file configurations/SQLInjection/default_constr.cfg -taint-analysis -print-final");
        configurations.put("UserKernelTrustError", "-config-file configurations/UserKernelTrustError/default.cfg -constr-config-file configurations/UserKernelTrustError/default_constr.cfg -taint-analysis -print-final");
        configurations.put("XSS", "-config-file configurations/XSS/default.cfg -constr-config-file configurations/XSS/default_constr.cfg -taint-analysis -print-final");
        
        if (System.getProperty("framac.path") != null)
            FRAMAC_PATH = System.getProperty("framac.path");
        else
            FRAMAC_PATH = "frama-c";
        
        if (System.getProperty("framac.cfg.path") != null)
            FRAMAC_CFG_PATH = System.getProperty("framac.cfg.path");
        else
            FRAMAC_CFG_PATH = "/tmp";
        
        dbs = AlitheiaCore.getInstance().getDBService();
        
        exportConfigurations();
    }

    public List<Result> getResult(ProjectFile a, Metric m) {
        // Return a list of ResultEntries by querying the DB for the 
        // measurements implement by the supported metric and calculated 
        // for the specific project file.
        return null;
    }
    
    public int runReadOutput(Process pr, String name) throws IOException {
        OutReader outReader = new OutReader(pr.getInputStream(), name);
        outReader.start();
        int retVal = -1;
        while (retVal == -1) {
            try {
                retVal = pr.waitFor();
            } catch (Exception ignored) {}
        }
        return retVal;
    }
    
    public void run(ProjectFile a) {
        // 1. Get stuff related to the provided project file
        // 2. Calculate one or more numbers
        // 3. Store a result to the database
    	
    	if (!a.getIsDirectory()){
	    	String out = a.getName() + "-out.txt";
	    	String confCommand;
	    	String framaCOut;
	    	try {
	    		
	    		for(String conf: configurationMetrics.keySet()){
	    			//Build of the command for Frama-C
	    			List<String> framacArgs = new ArrayList<String>();
	    			confCommand = String.format("-config-file configurations/%s/default.cfg -constr-config-file configurations/%s/default_constr.cfg -taint-analysis -print-final",conf,conf);
	    			framaCOut = String.format("%s/results/%s/%s_output.txt",FRAMAC_CFG_PATH,conf,a.getName());
	    			framacArgs.add("frama-c.byte ");
	    			framacArgs.add(" ");
	    			framacArgs.add(confCommand);
	    			framacArgs.add(" ");
	    			framacArgs.add(a.getName());
	    			framacArgs.add(" > ");
	    			framacArgs.add(framaCOut);
	    			
	    			ProcessBuilder framac = new ProcessBuilder(framacArgs);
	    			framac.redirectErrorStream(true);
	    			int retVal = runReadOutput(framac.start(), out);
	    			
	                if (retVal != 0) {
	                    log.warn("Frama-C failed. See file: " + out);
	                }
	
	                File f = new File(framaCOut);
	                storeResults(processResults(a,f,conf));
	    	   }
	        } catch (FileNotFoundException e) {
	            e.printStackTrace();
	        }  catch (IOException e) {
	            e.printStackTrace();
	        } catch (Throwable t) {
	            t.printStackTrace();
	        }
    	}
    }
	
	public List<ProjectFileVulnerability> processResults(ProjectFile a, File outputFile, String config)
			throws AlreadyProcessingException, Exception {
		// 1. parse the external tool output file
		// 2. extract detected vulnerabilities
		// 3. store them in the database
		SecurityProfileComponent spc = TracerPlatform.getInstance().getComponent(SecurityProfileComponent.class);
		boolean foundVulnerability = false;
		String contents = FileUtils.readContents(outputFile);
    	String locationAttack = "Location of " + config + " Attack:";
    	String descriptionAttack = "Description of " + config + " Attack: Tainted at ";
    	
    	if(contents == null)
    		return Collections.emptyList();
    	
    	List<ProjectFileVulnerability> results = new ArrayList<ProjectFileVulnerability>();
    	
    	String[] entries = contents.split(splitEntryPatternRegex);
    	for(String entry: entries) {
    		
    		Matcher matcher = symnamePattern.matcher(entry);
    		while(matcher.find()) {
    			
    			// get the vulnerability type and location,
    			//increment the appropriate metrics
    			if (matcher.group(2).equals("Tainted")){
    				foundVulnerability = true;
    				String symname = matcher.group(1);
    				locationAttack = locationAttack + "   " + symname;
    				descriptionAttack = descriptionAttack + "   " + symname;
    			}
    		}
    	}
    	
    	VulnerabilityType vt = spc.searchVulnerabilityType(config);
    	ProjectFileVulnerability pfv = new ProjectFileVulnerability();
		pfv.setDescription(config);
		pfv.setLocation(locationAttack);
		pfv.setDescription(descriptionAttack);
		pfv.setProjectFile(a);
		pfv.setVulnerabilityType(vt);
		results.add(pfv);
		
		if (foundVulnerability)
			return results;
		else
			return Collections.emptyList();
	}
	
	private void storeResults(List<ProjectFileVulnerability> results){
		
		VulnerabilityDetectionComponent vdc = TracerPlatform.getInstance().getComponent(VulnerabilityDetectionComponent.class);

		vdc.addToDetectedVulnerabilities(results);
	}
	
	private class OutReader extends Thread {
        String name;
        InputStream input;

        public OutReader(InputStream in, String name) {
            this.name = name;
            this.input = in;
        }

        public void run() {
            try {
                BufferedReader in = new BufferedReader(new InputStreamReader(input));
                FileWriter out = new FileWriter(new File(name), true);

                char[] buf = new char[8192];
                while (true) {
                    int length = in.read(buf);
                    if (length < 0)
                        break;
                    out.write(buf, 0, length);
                    out.flush();
                }
                in.close();
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

// vi: ai nosi sw=4 ts=4 expandtab
