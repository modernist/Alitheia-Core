/* This is the package for this particular plug-in. Third-party
** applications will want a different package name, but it is
** *ESSENTIAL* that the package name contain the string '.metrics.'
** because this is how Alitheia Core discovers the metric plug-ins. 
*/
package gr.tracer.vulnerabilitydetectors.findbugsvd;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.osgi.framework.BundleContext;



/* These are imports of standard Alitheia core services and types.
** You are going to need these anyway; some others that you might
** need are the FDS and other Metric interfaces, as well as more
** DAO types from the database service.
*/
import eu.sqooss.service.abstractmetric.AlreadyProcessingException;
import eu.sqooss.service.abstractmetric.MetricDecl;
import eu.sqooss.service.abstractmetric.MetricDeclarations;
import eu.sqooss.service.abstractmetric.Result;
import eu.sqooss.service.abstractmetric.SchedulerHints;
import eu.sqooss.service.abstractmetric.InvocationOrder;
import eu.sqooss.service.db.DAObject;
import eu.sqooss.service.db.Metric;
import eu.sqooss.service.db.ProjectFile;
import eu.sqooss.service.db.ProjectFileMeasurement;
import eu.sqooss.service.db.ProjectVersion;
import eu.sqooss.service.db.ProjectVersionMeasurement;
import eu.sqooss.tracer.common.DetectedVulnerabilities;
import eu.sqooss.tracer.common.DetectedVulnerability;
import eu.sqooss.tracer.common.VulnerabilityDetectorBase;

/**
 * The VDSkeleton class actually implements the metrics and vulnerability
 * detection in this plug-in. It must extend VulnerabilityDetectorBase, so
 * that it can be called by the various metrics drivers.
 *  
 */ 
@MetricDeclarations(metrics = {
	//Security
	@MetricDecl(mnemonic = "DCDP",    activators = {ProjectFile.class}, descr = "Dm: Hardcoded constant database password"),
	@MetricDecl(mnemonic = "DEDP",    activators = {ProjectFile.class}, descr = "Dm: Empty database password"),
	@MetricDecl(mnemonic = "HRPTC",   activators = {ProjectFile.class}, descr = "HRS: HTTP cookie formed from untrusted input"),
	@MetricDecl(mnemonic = "HRPTHH",  activators = {ProjectFile.class}, descr = "HRS: HTTP Response splitting vulnerability"),
	@MetricDecl(mnemonic = "SNSPTE",  activators = {ProjectFile.class}, descr = "SQL: Nonconstant string passed to execute method on an SQL statement"),
	@MetricDecl(mnemonic = "SPSGFNS", activators = {ProjectFile.class}, descr = "SQL: A prepared statement is generated from a nonconstant String"),
	@MetricDecl(mnemonic = "XRPTJW",  activators = {ProjectFile.class}, descr = "XSS: JSP reflected cross site scripting vulnerability"),
	@MetricDecl(mnemonic = "XRPTSE",  activators = {ProjectFile.class}, descr = "XSS: Servlet reflected cross site scripting vulnerability in error page"),
	@MetricDecl(mnemonic = "XRPTSW",  activators = {ProjectFile.class}, descr = "XSS: Servlet reflected cross site scripting vulnerability"),

	//Malicious Code
	@MetricDecl(mnemonic = "DCCIDP",  activators = {ProjectFile.class}, descr = "DP: Classloaders should only be created inside doPrivileged block"),
	@MetricDecl(mnemonic = "DDIDP",   activators = {ProjectFile.class}, descr = "DP: Method invoked that should be only be invoked inside a doPrivileged block"),
	@MetricDecl(mnemonic = "EER",     activators = {ProjectFile.class}, descr = "EI: May expose internal representation by returning reference to mutable object"),
	@MetricDecl(mnemonic = "EER2",    activators = {ProjectFile.class}, descr = "EI2: May expose internal representation by incorporating reference to mutable object"),
	@MetricDecl(mnemonic = "FPSBP",   activators = {ProjectFile.class}, descr = "FI: Finalizer should be protected, not public"),
	@MetricDecl(mnemonic = "EESR",    activators = {ProjectFile.class}, descr = "MS: May expose internal static state by storing a mutable object into a static field"),
	@MetricDecl(mnemonic = "MCBF",    activators = {ProjectFile.class}, descr = "MS: Field isn't final and can't be protected from malicious code"),
	@MetricDecl(mnemonic = "MER",     activators = {ProjectFile.class}, descr = "MS: Public static method may expose internal representation by returning array"),
	@MetricDecl(mnemonic = "MFP",     activators = {ProjectFile.class}, descr = "MS: Field should be both final and package protected"),
	@MetricDecl(mnemonic = "MMA",     activators = {ProjectFile.class}, descr = "MS: Field is a mutable array"),
	@MetricDecl(mnemonic = "MMH",     activators = {ProjectFile.class}, descr = "MS: Field is a mutable Hashtable"),
	@MetricDecl(mnemonic = "MOP",     activators = {ProjectFile.class}, descr = "MS: Field should be moved out of an interface and made package protected"),
	@MetricDecl(mnemonic = "MP",      activators = {ProjectFile.class}, descr = "MS: Field should be package protected"),
	@MetricDecl(mnemonic = "MSBF",    activators = {ProjectFile.class}, descr = "MS: Field isn't final but should be"),

	//Summarized per project versions
	@MetricDecl(mnemonic = "TDCDP",    activators = {ProjectVersion.class}, descr = "Dm: Hardcoded constant database password (total)"),
	@MetricDecl(mnemonic = "TDEDP",    activators = {ProjectVersion.class}, descr = "Dm: Empty database password (total)"),
	@MetricDecl(mnemonic = "THRPTC",   activators = {ProjectVersion.class}, descr = "HRS: HTTP cookie formed from untrusted input (total)"),
	@MetricDecl(mnemonic = "THRPTHH",  activators = {ProjectVersion.class}, descr = "HRS: HTTP Response splitting vulnerability (total)"),
	@MetricDecl(mnemonic = "TSNSPTE",  activators = {ProjectVersion.class}, descr = "SQL: Nonconstant string passed to execute method on an SQL statement (total)"),
	@MetricDecl(mnemonic = "TSPSGFNS", activators = {ProjectVersion.class}, descr = "SQL: A prepared statement is generated from a nonconstant String (total)"),
	@MetricDecl(mnemonic = "TXRPTJW",  activators = {ProjectVersion.class}, descr = "XSS: JSP reflected cross site scripting vulnerability (total)"),
	@MetricDecl(mnemonic = "TXRPTSE",  activators = {ProjectVersion.class}, descr = "XSS: Servlet reflected cross site scripting vulnerability in error page (total)"),
	@MetricDecl(mnemonic = "TXRPTSW",  activators = {ProjectVersion.class}, descr = "XSS: Servlet reflected cross site scripting vulnerability (total)"),

	@MetricDecl(mnemonic = "TDCCIDP",  activators = {ProjectVersion.class}, descr = "DP: Classloaders should only be created inside doPrivileged block (total)"),
	@MetricDecl(mnemonic = "TDDIDP",   activators = {ProjectVersion.class}, descr = "DP: Method invoked that should be only be invoked inside a doPrivileged block (total)"),
	@MetricDecl(mnemonic = "TEER",     activators = {ProjectVersion.class}, descr = "EI: May expose internal representation by returning reference to mutable object (total)"),
	@MetricDecl(mnemonic = "TEER2",    activators = {ProjectVersion.class}, descr = "EI2: May expose internal representation by incorporating reference to mutable object (total)"),
	@MetricDecl(mnemonic = "TFPSBP",   activators = {ProjectVersion.class}, descr = "FI: Finalizer should be protected, not public (total)"),
	@MetricDecl(mnemonic = "TEESR",    activators = {ProjectVersion.class}, descr = "MS: May expose internal static state by storing a mutable object into a static field (total)"),
	@MetricDecl(mnemonic = "TMCBF",    activators = {ProjectVersion.class}, descr = "MS: Field isn't final and can't be protected from malicious code (total)"),
	@MetricDecl(mnemonic = "TMER",     activators = {ProjectVersion.class}, descr = "MS: Public static method may expose internal representation by returning array (total)"),
	@MetricDecl(mnemonic = "TMFP",     activators = {ProjectVersion.class}, descr = "MS: Field should be both final and package protected (total)"),
	@MetricDecl(mnemonic = "TMMA",     activators = {ProjectVersion.class}, descr = "MS: Field is a mutable array (total)"),
	@MetricDecl(mnemonic = "TMMH",     activators = {ProjectVersion.class}, descr = "MS: Field is a mutable Hashtable (total)"),
	@MetricDecl(mnemonic = "TMOP",     activators = {ProjectVersion.class}, descr = "MS: Field should be moved out of an interface and made package protected (total)"),
	@MetricDecl(mnemonic = "TMP",      activators = {ProjectVersion.class}, descr = "MS: Field should be package protected (total)"),
	@MetricDecl(mnemonic = "TMSBF",    activators = {ProjectVersion.class}, descr = "MS: Field isn't final but should be (total)")
})
@SchedulerHints(invocationOrder = InvocationOrder.NEWFIRST, activationOrder = {ProjectVersion.class})
@DetectedVulnerabilities(vulnerabilities = {
	@DetectedVulnerability(name="SQL Injection", description="SQL Injection Vulnerability",	activators={ProjectFile.class})
})
public class FindBugsVD extends VulnerabilityDetectorBase {
    
	private static String MAVEN_PATH = "";
    private static String ANT_PATH = "";
    private static String FINDBUGS_PATH = "";

    static {
        if (System.getProperty("findbugs.path") != null)
            FINDBUGS_PATH = System.getProperty("findbugs.path");
        else
            FINDBUGS_PATH = "findbugs";
        if (System.getProperty("mvn.path") != null)
            MAVEN_PATH = System.getProperty("mvn.path");
        else
            MAVEN_PATH = "mvn";
        if (System.getProperty("ant.path") != null)
            ANT_PATH = System.getProperty("ant.path");
        else
            ANT_PATH = "ant";
    }
	
    public FindBugsVD(BundleContext bc) {
        super(bc);        
    }

    public List<Result> getResult(ProjectFile pf, Metric m) {
        return getResult(pf, ProjectFileMeasurement.class,
                m, Result.ResultType.INTEGER);
    }

    public List<Result> getResult(ProjectVersion pv, Metric m) {
        return getResult(pv, ProjectVersionMeasurement.class,
                m, Result.ResultType.INTEGER);
    }
    
    // only run per project version
    public void run(ProjectFile a) {
    }
	
    // only run per project version
	public void processResults(ProjectFile a, File outputFile)
			throws AlreadyProcessingException, Exception {
	}
	
	public void processResults(ProjectVersion pv, File outputFile)
			throws AlreadyProcessingException, Exception {
		
	}

	@Override
	protected void processFile(DAObject o, File root, String targetConfiguration)
			throws IOException, AlreadyProcessingException, Exception {
		// TODO Auto-generated method stub
		// This method should be implemented for the findbugs vulnerability detector
		// Below is the implementation of the method processFile from the vulnerability
		// detector base
		
//		String commandLine = buildExternalToolCommand(root, targetConfiguration);
//		ProcessBuilder pb = new ProcessBuilder(commandLine);
//		pb.redirectErrorStream(true);
//		File tempFile = File.createTempFile(getClass().getName(), null);
//		int exitCode = getProcessExitCode(pb.start(), tempFile.getAbsolutePath());
//		if(exitCode != 0) {
//			log.warn("Failed to invoke external tool");
//		} else {
//			processResults(o, tempFile);
//		}
//		tempFile.delete();
	}

	@Override
	protected List<String> buildExternalToolCommand(File file,
			String configurationName) {
		// TODO Auto-generated method stub
		return null;
	}
	
}

// vi: ai nosi sw=4 ts=4 expandtab
