package gr.tracer.common;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.osgi.framework.BundleContext;

import eu.sqooss.core.AlitheiaCore;
import eu.sqooss.service.abstractmetric.AbstractMetric;
import eu.sqooss.service.abstractmetric.AlreadyProcessingException;
import eu.sqooss.service.db.DAObject;
import eu.sqooss.service.db.DBService;
import eu.sqooss.service.db.Metric;
import eu.sqooss.service.db.MetricMeasurement;
import eu.sqooss.service.db.PluginConfiguration;
import eu.sqooss.service.db.ProjectFile;
import eu.sqooss.service.db.ProjectVersion;
import eu.sqooss.service.db.StoredProject;
import eu.sqooss.service.fds.FDSService;
import eu.sqooss.service.fds.OnDiskCheckout;
import eu.sqooss.service.pa.PluginInfo;
import eu.sqooss.service.util.FileUtils;
import gr.tracer.common.DetectedVulnerabilities;
import gr.tracer.common.DetectedVulnerability;
import gr.tracer.common.entities.db.ProjectFileVulnerability;
import gr.tracer.common.entities.db.ProjectVersionVulnerability;
import gr.tracer.common.entities.db.StoredProjectVulnerability;
import gr.tracer.common.entities.db.Vulnerability;
import gr.tracer.common.entities.db.VulnerabilityType;
import gr.tracer.common.utils.ProcessOutputReader;

public abstract class VulnerabilityDetectorBase extends AbstractMetric implements VulnerabilityDetector {
	
	/** Reference to the FDS service, not to be passed to metric jobs */
	private FDSService fds;
	
	/** Reference to the DB service */
	private DBService dbs;
	
	/** The path to the external tool that will be used to detect vulnerabilities */
	private String externalToolPath;
	
	/** The invocation mode to be used for the external tool */
	private ExternalToolInvocationMode invocationMode;
	
	/** The name of the currently active external tool configuration */
	private String activeConfigurationName;
	
	/** The set of different configurations that are supported by the external tool */
	protected Map<String, Object> configurations;
	
	/** The current configuration handling mode */
	private ConfigurationHandlingMode configurationHandlingMode;
	
	/** The set of vulnerability types detected by the external tool, populated during initialization */
	protected List<VulnerabilityType> detectedVulnerabilityTypes;
	
	protected VulnerabilityDetectorBase(BundleContext bc) {
		super(bc);
		
		configurationHandlingMode = ConfigurationHandlingMode.NO_CONFIGURATION;
		
		fds = AlitheiaCore.getInstance().getFDSService();
		
		if(fds == null)
            log.error("Could not get a reference to the FDS service");
		
		dbs = AlitheiaCore.getInstance().getDBService();
		if(dbs == null)
			log.error("Could not get a reference to the DB service");
		
		configurations = new HashMap<String, Object>();
	}
	
	/** {@inheritDoc} */
	@Override
	public boolean install() {
		boolean result = super.install();
		if (result) {
			addConfigEntry("externalToolPath", "",
					"Path of the external tool executable",
					PluginInfo.ConfigurationType.STRING);

			addConfigEntry("activeConfiguration", "",
					"Name of the active configuration for the external tool",
					PluginInfo.ConfigurationType.STRING);
		}
		
		result &= registerDetectedVulnerabilityTypes();
		
		return result;
	}
	
	
	/* 
	 * @see gr.tracer.common.VulnerabilityDetector#getDetectedVulnerabilityTypes()
	 */
	@Override
	public List<VulnerabilityType> getDetectedVulnerabilityTypes() {
		if(detectedVulnerabilityTypes == null) {
			if(!registerDetectedVulnerabilityTypes()) {
				return null;
			}
		}
		return detectedVulnerabilityTypes;
	}
	
	/**
	 * Builds the command line that must be executed so that the external tool
	 * can process a file or directory
	 * @param file The file or directory to be processed
	 * @param configurationName The name of the external tool configuration to be used
	 * @return The command to be used for executing the external tool
	 */
	protected String buildExternalToolCommand(File file,
			String configurationName) {
		if (null == configurationName
				|| (!configurations.containsKey(configurationName))
				|| configurationName.isEmpty()) {
			return String.format("%s %s", externalToolPath, file.getPath());
		} else {
			return String.format("%s %s %s", externalToolPath, configurations
					.get(configurationName).toString(), file.getPath());
		}
	}
	
	/*
	 * @see gr.tracer.common.VulnerabilityDetector#processResults(eu.sqooss.service.db.DAObject, java.io.File)
	 */
    @Override
	public void processResults(DAObject o, File outputFile) throws 
    	AlreadyProcessingException, Exception {

        try {
            Method m = findMethod("processResults", o.getClass());
            m.invoke(this, o);
        } catch (SecurityException e) {
            logInvocationError("processResults", o, e);
        } catch (NoSuchMethodException e) {
            logInvocationError("processResults", o, e);
        } catch (IllegalArgumentException e) {
            logInvocationError("processResults", o, e);
        } catch (IllegalAccessException e) {
            logInvocationError("processResults", o, e);
        } catch (InvocationTargetException e) {
            // Forward exception to metric job exception handler
            if (e.getCause() instanceof AlreadyProcessingException) {
                throw (AlreadyProcessingException) e.getCause();
            } else {
                if (e != null && e.getCause() != null) {
                    logInvocationError("processResults", o, e);
                    if (e.getCause() != null)
                        throw new Exception(e.getCause());
                    else
                        throw new Exception(e);
                }
            }
        }
    }
    
    @Override
    /** Default implementation of run method */
	public void run(DAObject o) throws 
    	AlreadyProcessingException, Exception {
    	
    	Set<String> configs = new HashSet<String>();
    	
    	switch(configurationHandlingMode) {
    		case NO_CONFIGURATION:
    			configs.add("");
    			break;
    			
    		case ACTIVE_CONFIGURATION:
    			String ac = getActiveConfigurationName();
    			configs.add(ac == null ? "" : ac);
    			break;
    			
    		case ALL_CONFIGURATIONS:
    			for(String conf : configurations.keySet()) {
    				configs.add(conf == null ? "" : conf);
    			}
    			break;
    			
    		default:
    			break;
    	}
    	
    	ProjectVersion targetVersion = null;
    	List<ProjectFile> files = new ArrayList<ProjectFile>();
    	
    	if(o.getClass() == StoredProject.class) {
    		targetVersion = ProjectVersion.getLastProjectVersion((StoredProject)o);
    		files.addAll(targetVersion.getFiles());
    	} else if(o.getClass() == ProjectVersion.class) {
    		targetVersion = (ProjectVersion)o;
    		files.addAll(targetVersion.getFiles());
    	} else if(o.getClass() == ProjectFile.class) {
    		targetVersion = ((ProjectFile)o).getProjectVersion();
    		files.add((ProjectFile)o);
    	}
    	
    	if(targetVersion == null) {
    		log.info("Unsupported target type: " + o.getClass().toString());
    	}
    	    	
    	OnDiskCheckout odc = fds.getCheckout(targetVersion, "/");
    	File root = odc.getRoot();
    	
    	for(String targetConfiguration : configs) {
    		//run the external tool for each configuration
    		if(invocationMode == ExternalToolInvocationMode.PER_PROJECT_FILE) {
    			List<File> physicalFiles = FileUtils.listRecursively(root, true);
    			for(File f: physicalFiles) {
    				ProjectFile pf = findFile(files, f.getPath());
    				processFile(pf, f, targetConfiguration);
    			}
    			
    		} else {
    			processFile(o, root, targetConfiguration);
    		}
    	}
    	
    }

	private void processFile(DAObject o, File root, String targetConfiguration)
			throws IOException, AlreadyProcessingException, Exception {
		String commandLine = buildExternalToolCommand(root, targetConfiguration);
		ProcessBuilder pb = new ProcessBuilder(commandLine);
		pb.redirectErrorStream(true);
		File tempFile = File.createTempFile(getClass().getName(), null);
		int exitCode = getProcessExitCode(pb.start(), tempFile.getAbsolutePath());
		if(exitCode != 0) {
			log.warn("Failed to invoke external tool");
		} else {
			processResults(o, tempFile);
		}
		tempFile.delete();
	}
    
    private ProjectFile findFile(List<ProjectFile> files, String path) {
        for(ProjectFile pf: files) {
            if (pf.getFileName().endsWith(path))
                return pf;
        }
        return null;
    }
    
    /* Stores the detected vulnerabilities in the database. Overrides of this 
     * method should aggregate vulnerabilities per project file / version and 
     * store the appropriate measurements */
    protected void storeDetectedVulnerabilities(List<Vulnerability> detectedVulnerabilities) {
    	
    	dbs.startDBSession();
    	dbs.addRecords(detectedVulnerabilities);
    	dbs.commitDBSession();
    	
    	for(Vulnerability vulnerability : detectedVulnerabilities) {
    		if(vulnerability.getClass() == ProjectVersionVulnerability.class) {
    			
    		} else if (vulnerability.getClass() == ProjectFileVulnerability.class) {
    			
    		} else if (vulnerability.getClass() == StoredProjectVulnerability.class) {
    			
    		}
    	}
    }
    
    protected boolean measurementExists(ProjectVersion pv, Metric m) {
        String q = "from ProjectVersionMeasurement pvm " +
                "where pvm.metric = :metric " +
                "and pvm.projectVersion = :version";

        Map<String,Object> parameters = new HashMap<String,Object>();
        parameters.put("metric", m);
        parameters.put("version", pv);

        return dbs.doHQL(q, parameters).size() > 0;
    }
    
    protected boolean measurementExists(ProjectFile pf, Metric m) {
        String q = "from ProjectFileMeasurement pfm " +
                "where pfm.metric = :metric " +
                "and pfm.projectFile = :file";

        Map<String,Object> parameters = new HashMap<String,Object>();
        parameters.put("metric", m);
        parameters.put("file", pf);

        return dbs.doHQL(q, parameters).size() > 0;
    }

    
    /* 
	 * @see gr.tracer.common.VulnerabilityDetector#getExternalToolPath()
	 */
	@Override
	public String getExternalToolPath() {
		return externalToolPath;
	}

	protected void setExternalToolPath(String externalToolPath) {
		this.externalToolPath = externalToolPath;
		//PluginConfiguration conf = getConfigurationOption("externalToolPath");
		//if(conf != null) {
		//	conf.setValue(externalToolPath);
		//}
	}
	
	/* 
	 * @see gr.tracer.common.VulnerabilityDetector#getActiveConfigurationName()
	 */
	@Override
	public String getActiveConfigurationName() {
		//if(activeConfigurationName == null || activeConfigurationName.isEmpty()) {
		//	activeConfigurationName = getConfigurationOption("activeConfiguration").getValue();
		//}
		return activeConfigurationName;
	}

	protected void setActiveConfigurationName(String name) {
		this.activeConfigurationName = name;
		//PluginConfiguration conf = getConfigurationOption("activeConfiguration");
		//if(conf != null) {
		//	conf.setValue(name);
		//}
	}
	
	@Override 
	public ConfigurationHandlingMode getConfigurationHandlingMode() {
		return configurationHandlingMode;
	};
	
	protected void setConfigurationHandlingMode(ConfigurationHandlingMode mode) {
		configurationHandlingMode = mode;
	}
	
	@Override
	public ExternalToolInvocationMode getExternalToolInvocationMode() {
		return invocationMode;
	}

	protected void setExternalToolInvocationMode(ExternalToolInvocationMode invocationMode) {
		this.invocationMode = invocationMode;
	}
	
	/**
	 * Registers information about detected vulnerability types.
	 * 
	 * @return true on successful registration
	 */
	private boolean registerDetectedVulnerabilityTypes() {
		boolean result = true;
		if(detectedVulnerabilityTypes == null)
			detectedVulnerabilityTypes = new ArrayList<VulnerabilityType>();
		
		DBService dbs = AlitheiaCore.getInstance().getDBService();
		dbs.startDBSession();
		
		Map<String, VulnerabilityType> vtNames = new HashMap<String, VulnerabilityType>();
		for(VulnerabilityType vt : VulnerabilityType.getVulnerabilityTypes()) {
			vtNames.put(vt.getName(), vt);
		}
		
		DetectedVulnerabilities vulnerabilities = this.getClass().getAnnotation(DetectedVulnerabilities.class);
		if(vulnerabilities != null && vulnerabilities.vulnerabilities().length > 0) {
			
			for(DetectedVulnerability vulnerability : vulnerabilities.vulnerabilities()) {
				
				if(!vtNames.containsKey(vulnerability.name())) {
					VulnerabilityType vt = new VulnerabilityType();
					vt.setName(vulnerability.name());
					vt.setDescription(vulnerability.description());
					result &= dbs.addRecord(vt) && detectedVulnerabilityTypes.add(vt);
				} else {
					detectedVulnerabilityTypes.add(vtNames.get(vulnerability.name()));
				}
			}
			result &= dbs.commitDBSession();
		} else {
			log.error("No detected vulnerabilities declared");
			result = false;
		}
		return result;
	}
	
	/**
	 * Waits for a process to finish while reading its output
	 * @param pr The process to wait for
	 * @param fileName the name of the file where the process output is written
	 * @return the process exit code
	 * @throws IOException
	 */
	protected int getProcessExitCode(Process pr, String fileName) throws IOException {
        ProcessOutputReader outReader = new ProcessOutputReader(pr.getInputStream(), fileName);
        outReader.start();
        int retVal = -1;
        while (retVal == -1) {
            try {
                retVal = pr.waitFor();
            } catch (Exception ignored) {}
        }
        return retVal;
    }
    
    private Method findMethod(String name, Class<?> clazz) 
        throws NoSuchMethodException {
        Method m = null;
        
        try {
            m = this.getClass().getMethod(name, clazz, File.class);                
        } catch (NoSuchMethodException nsme) {
            try {
                m = this.getClass().getMethod(name, clazz.getSuperclass(), File.class);
            } catch (NoSuchMethodException nsme1) {
                throw nsme;
            }
        }
       
        return m;
    }
    
    private void logInvocationError(String method, DAObject o, Exception e) {
        log.error("Plugin:" + this.getClass().toString() + 
                "\nDAO id: " + o.getId() + 
                "\nDAO class: " + o.getClass() +
                "\nDAO toString(): " + o.toString() +
                "\nError when invoking the " + method + " method." +
                "\nException:" + e.getClass().getName() +
                "\nError:" + e.getMessage() + 
                "\nReason:" + e.getCause(), e);
    }

}
