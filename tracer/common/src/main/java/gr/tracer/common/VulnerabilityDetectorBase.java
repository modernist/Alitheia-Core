package gr.tracer.common;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.osgi.framework.BundleContext;

import eu.sqooss.core.AlitheiaCore;
import eu.sqooss.service.abstractmetric.AbstractMetric;
import eu.sqooss.service.abstractmetric.AlreadyProcessingException;
import eu.sqooss.service.db.DAObject;
import eu.sqooss.service.db.DBService;
import eu.sqooss.service.fds.FDSService;
import eu.sqooss.service.pa.PluginInfo;
import gr.tracer.common.DetectedVulnerabilities;
import gr.tracer.common.DetectedVulnerability;
import gr.tracer.common.entities.db.VulnerabilityType;
import gr.tracer.common.utils.ProcessOutputReader;

public abstract class VulnerabilityDetectorBase extends AbstractMetric {
	
	/** Reference to the FDS service, not to be passed to metric jobs */
	protected FDSService fds;
	
	/** The path to the external tool that will be used to detect vulnerabilities */
	protected String externalToolPath;
	
	/** The name of the currently active external tool configuration */
	protected String activeConfiguration;
	
	/** The set of different configurations that are supported by the external tool */
	protected Map<String, Object> configurations;
	
	/** The set of vulnerability types detected by the external tool, populated during initialization */
	protected List<VulnerabilityType> detectedVulnerabilityTypes;
	
	/** An enumeration of the different configuration handling modes */
	public enum ConfigurationHandlingMode {
		/** No configuration options required by the external tool */
		NO_CONFIGURATION,
		/** The processing will take place using only the active configuration */
		ACTIVE_CONFIGURATION,
		/** The processing will take place using all available configurations sequentially */
		ALL_CONFIGURATIONS
	}
	
	/** The current configuration handling mode */
	protected ConfigurationHandlingMode configurationHandlingMode;
	
	protected VulnerabilityDetectorBase(BundleContext bc) {
		super(bc);
		
		configurationHandlingMode = ConfigurationHandlingMode.NO_CONFIGURATION;
		
		fds = AlitheiaCore.getInstance().getFDSService();
		
		if(fds == null)
            log.error("Could not get a reference to the FDS service");
	}
	
	/** {@inheritDoc} */
	@Override
	public boolean install() {
		boolean result = super.install();
		if (result) {
			addConfigEntry("externalToolPath", "",
					"Path of the external tool executable",
					PluginInfo.ConfigurationType.STRING);

			addConfigEntry("activeConfiguration", "",
					"Name of the active configuration for the external tool",
					PluginInfo.ConfigurationType.STRING);
		}
		
		result &= registerDetectedVulnerabilityTypes();
		
		return result;
	}

	/**
	 * Registers information about detected vulnerability types
	 * 
	 * @return true on successful registration
	 */
	private boolean registerDetectedVulnerabilityTypes() {
		boolean result = true;
		if(detectedVulnerabilityTypes == null)
			detectedVulnerabilityTypes = new ArrayList<VulnerabilityType>();
		
		DBService dbs = AlitheiaCore.getInstance().getDBService();
		dbs.startDBSession();
		
		Map<String, VulnerabilityType> vtNames = new HashMap<String, VulnerabilityType>();
		for(VulnerabilityType vt : VulnerabilityType.getVulnerabilityTypes()) {
			vtNames.put(vt.getName(), vt);
		}
		
		DetectedVulnerabilities vulnerabilities = this.getClass().getAnnotation(DetectedVulnerabilities.class);
		if(vulnerabilities != null && vulnerabilities.vulnerabilities().length > 0) {
			
			for(DetectedVulnerability vulnerability : vulnerabilities.vulnerabilities()) {
				
				if(!vtNames.containsKey(vulnerability.name())) {
					VulnerabilityType vt = new VulnerabilityType();
					vt.setName(vulnerability.name());
					vt.setDescription(vulnerability.description());
					result &= dbs.addRecord(vt) && detectedVulnerabilityTypes.add(vt);
				} else {
					detectedVulnerabilityTypes.add(vtNames.get(vulnerability.name()));
				}
			}
			result &= dbs.commitDBSession();
		} else {
			log.error("No detected vulnerabilities declared");
			result = false;
		}
		return result;
	}
	
	/** Returns a list of the types of vulnerabilities detected by the plugin */
	public List<VulnerabilityType> getDetectedVulnerabilityTypes() {
		if(detectedVulnerabilityTypes == null) {
			if(!registerDetectedVulnerabilityTypes()) {
				return null;
			}
		}
		return detectedVulnerabilityTypes;
	}
	
	/**
	 * Builds the command line that must be executed so that the external tool
	 * can process a file or directory
	 * @param file The path of the file or directory to be processed
	 * @param configurationName The name of the external tool configuration to be used
	 * @return The command to be used for executing the external tool
	 */
	protected String buildExternalToolCommand(File file,
			String configurationName) {
		if (null == configurationName
				|| (!configurations.containsKey(configurationName))
				|| configurationName.isEmpty()) {
			return String.format("%s %s", externalToolPath, file.getPath());
		} else {
			return String.format("%s %s %s", externalToolPath, configurations
					.get(configurationName).toString(), file.getPath());
		}
	}
	
	/**
	 * Waits for a process to finish while reading its output
	 * @param pr
	 * @param fileName
	 * @return
	 * @throws IOException
	 */
	private int getProcessExitCode(Process pr, String fileName) throws IOException {
        ProcessOutputReader outReader = new ProcessOutputReader(pr.getInputStream(), fileName);
        outReader.start();
        int retVal = -1;
        while (retVal == -1) {
            try {
                retVal = pr.waitFor();
            } catch (Exception ignored) {}
        }
        return retVal;
    }
	
	/**
     * Call the appropriate processResults() method according to the type of the entity
     * that is being processed.
     *
     * @param o
     *                DAO which determines which sub-interface processResults
     *                method is called.
     * @param outputFile
     * 				  The file containing the output of the external tool
     */
    public void processResults(DAObject o, File outputFile) throws 
    	AlreadyProcessingException, Exception {

        try {
            Method m = findMethod("processResults", o.getClass());
            m.invoke(this, o);
        } catch (SecurityException e) {
            logInvocationError("processResults", o, e);
        } catch (NoSuchMethodException e) {
            logInvocationError("processResults", o, e);
        } catch (IllegalArgumentException e) {
            logInvocationError("processResults", o, e);
        } catch (IllegalAccessException e) {
            logInvocationError("processResults", o, e);
        } catch (InvocationTargetException e) {
            // Forward exception to metric job exception handler
            if (e.getCause() instanceof AlreadyProcessingException) {
                throw (AlreadyProcessingException) e.getCause();
            } else {
                if (e != null && e.getCause() != null) {
                    logInvocationError("processResults", o, e);
                    if (e.getCause() != null)
                        throw new Exception(e.getCause());
                    else
                        throw new Exception(e);
                }
            }
        }
    }
    
    private Method findMethod(String name, Class<?> clazz) 
        throws NoSuchMethodException {
        Method m = null;
        
        try {
            m = this.getClass().getMethod(name, clazz, File.class);                
        } catch (NoSuchMethodException nsme) {
            try {
                m = this.getClass().getMethod(name, clazz.getSuperclass(), File.class);
            } catch (NoSuchMethodException nsme1) {
                throw nsme;
            }
        }
       
        return m;
    }
    
    private void logInvocationError(String method, DAObject o, Exception e) {
        log.error("Plugin:" + this.getClass().toString() + 
                "\nDAO id: " + o.getId() + 
                "\nDAO class: " + o.getClass() +
                "\nDAO toString(): " + o.toString() +
                "\nError when invoking the " + method + " method." +
                "\nException:" + e.getClass().getName() +
                "\nError:" + e.getMessage() + 
                "\nReason:" + e.getCause(), e);
    }
}
